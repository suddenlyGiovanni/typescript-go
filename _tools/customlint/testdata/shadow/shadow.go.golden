	package shadow
	
	func F1() int {
		value := 1
		if value == 1 {
			value := 2 // Bad
			~~~~~
!!! shadow: declaration of "value" shadows declaration at line 4 and is reachable from use at line 9
			println(value)
		}
		return value
	}
	
	func F1a() int {
		value := 1
		if value == 1 {
			value := 2 // OK
			println(value)
		}
		return 1234
	}
	
	func F2() int {
		value := 1
		if value == 1 {
			value := 2 // OK
			println(value)
			return value
		}
		return value
	}
	
	func F2a() int {
		value := 1
		if value == 1 {
			value := 2 // OK
			println(value)
			return value
		}
		return 1234
	}
	
	func F3(value int) int {
		if value == 1 {
			value := 2 // Bad
			~~~~~
!!! shadow: declaration of "value" shadows declaration at line 41 and is reachable from use at line 46
			println(value)
		}
		return value
	}
	
	func F4(value int) int {
		if value == 1 {
			value := 2 // OK
			println(value)
			return value
		}
		return value
	}
	
	type isType int
	
	func F5() isType {
	          ~
!!! unexportedapi: exported API references unexported identifier isType
		var isType isType // OK
		return isType
	}
	
	type isAlias int
	
	func F6() isAlias {
	          ~
!!! unexportedapi: exported API references unexported identifier isAlias
		var isAlias isAlias // OK
		return isAlias
	}
	
	func F7() int {
		value := 1
	
		fn := func() {
			value := 2 // Bad
			~~~~~
!!! shadow: declaration of "value" shadows non-local declaration at line 73
			println(value)
		}
	
		fn()
		fn()
	
		return value
	}
	
	func F8() int {
		value := 1
	
		fn := func() int {
			value := 2 // Dubious
			~~~~~
!!! shadow: declaration of "value" shadows non-local declaration at line 87
			println(value)
			return value
		}
	
		fn()
		fn()
	
		return value
	}
	
	func callIt(fn func()) {
		fn()
	}
	
	func F9() int {
		value := 1
	
		callIt(func() {
			value := 2 // Bad
			~~~~~
!!! shadow: declaration of "value" shadows non-local declaration at line 106
			println(value)
		})
	
		return value
	}
	
	func callIt2(fn func() int) int {
		return fn()
	}
	
	func F10() int {
		value := 1
	
		callIt2(func() int {
			value := 2 // Bad
			~~~~~
!!! shadow: declaration of "value" shadows non-local declaration at line 121
			println(value)
			return value
		})
	
		return value
	}
	
	func F11() int {
		value := 1
	
		callIt(func() {
			value := 2 // Bad
			~~~~~
!!! shadow: declaration of "value" shadows non-local declaration at line 133
	
			callIt(func() {
				value := 3 // Bad
				~~~~~
!!! shadow: declaration of "value" shadows non-local declaration at line 136
				println(value)
			})
	
			println(value)
		})
	
		return value
	}
	
	func F12() int {
		value := 1
		if value == 1 {
			value := value // Bad
			~~~~~
!!! shadow: declaration of "value" shadows declaration at line 150 and is reachable from use at line 155
			println(value)
		}
		return value
	}
	
	func F12a(value int) int {
		if value == 1 {
			value := value // Bad
			~~~~~
!!! shadow: declaration of "value" shadows declaration at line 158 and is reachable from use at line 163
			println(value)
		}
		return value
	}
	
	func F12b() int {
		value := 1
		if value == 1 {
			value, other := value, 1234 // Bad
			~~~~~
!!! shadow: declaration of "value" shadows declaration at line 167 and is reachable from use at line 172
			println(value, other)
		}
		return value
	}
	
	func F13() int {
		value := 1
		if value == 1 {
			value := value // OK
			println(value)
			return value
		}
		return value
	}
	
	func F13a(value int) int {
		if value == 1 {
			value := value // OK
			println(value)
			return value
		}
		return value
	}
	
	func F13b() int {
		value := 1
		if value == 1 {
			value, other := value, 1234 // OK
			println(value, other)
			return value
		}
		return value
	}
	
	var globalValue int
	
	func F14a() int {
		if globalValue == 1 {
			globalValue := 2 // Bad
			~~~~~~~~~~~
!!! shadow: declaration of "globalValue" shadows non-local declaration at line 204
			println(globalValue)
		}
		return globalValue
	}
	
	func F14b() int {
		if globalValue == 1 {
			globalValue := 2 // Dubious
			~~~~~~~~~~~
!!! shadow: declaration of "globalValue" shadows non-local declaration at line 204
			println(globalValue)
			return globalValue
		}
		return globalValue
	}
	
	func F15(m1 map[string]int, m2 map[string]int) int {
		if v1, ok := m1["a"]; ok {
			if v2, ok := m2["a"]; ok { // OK
				return v1 + v2
			}
		}
		return 0
	}
	
	func F16() {
		foo := 1
		bar := 2
		println(foo, bar)
	
		callIt(func() {
			foo := 3 // Bad
			~~~
!!! shadow: declaration of "foo" shadows non-local declaration at line 233
			bar := 4 // Bad
			~~~
!!! shadow: declaration of "bar" shadows non-local declaration at line 234
			println(foo, bar)
		})
	}
	
	func F16b() {
		foo := 1
		bar := 2
		println(foo, bar)
	
		callIt(func() {
			foo := 3 // Bad
			~~~
!!! shadow: declaration of "foo" shadows non-local declaration at line 245
			bar := 4 // Bad
			~~~
!!! shadow: declaration of "bar" shadows non-local declaration at line 246
			println(foo, bar)
		})
	
		println(foo, bar)
	}
	
	type someError struct{}
	
	func (*someError) Error() string {
		return "some error"
	}
	
	var errSome = &someError{}
	
	func F17(read func() (v any, err error), sendError func(error) error) error {
		for {
			v, err := read()
			if err != nil {
				if err == errSome {
					// OK: use after asignnent above; switching to = below would not be observable.
					if err := sendError(err); err != nil {
						return err
					}
					continue
				}
				return err
			}
			println(v)
		}
	}
	
	func F17b(read func() (v any, err error), sendError func(error) error) error {
		for {
			v, err := read()
			if err != nil {
				return err
			}
			if v == "bad value" {
				// OK: use after asignnent above; switching to = below would not be observable.
				if err := sendError(err); err != nil {
					return err
				}
			}
		}
	}
	
	func F18(index int) int {
		return callIt2(func() int {
			if index == 0 {
				return 1234
			}
	
			if index == 1 {
				// Dubuious; did this mean to keep the value for another execution?
				index := 2
				~~~~~
!!! shadow: declaration of "index" shadows non-local declaration at line 298
				println(index)
				return index
			}
	
			println(index)
			return index
		})
	}
	
	func F19() {
		value := 1
	
		print := func() {
			println(value)
		}
	
		setAndPrint := func(v int) {
			value := v
			~~~~~
!!! shadow: declaration of "value" shadows non-local declaration at line 317
			println(value)
		}
	
		setAndPrint(1234)
		print()
	}
	
	func F19b() {
		value := 1
	
		print := func() {
			println(value)
		}
	
		setAndPrint := func(v int) {
			println(value)
			value := v
			~~~~~
!!! shadow: declaration of "value" shadows non-local declaration at line 333
			println(value)
		}
	
		setAndPrint(1234)
		print()
	}
	
	func add(a, b int) int {
		return a + b
	}
	
	func F20(value int) int {
		switch {
		case value < 10:
			value := add(value, value) // OK
			if value < 10 {
				return value
			}
			return value + 1
		case value < 20:
			return value
		}
		return value
	}
	
	func F20a(value int) int {
		switch {
		case value < 10:
			println(value)
			value := add(value, value) // OK
			println(value)
			if value < 10 {
				return value
			}
			return value + 1
		case value < 20:
			return value
		}
		return value
	}
	
	// ============================================
	// Additional test cases for coverage
	// ============================================
	
	// Test regular assignment (not :=) - should not trigger shadow check
	func F21() int {
		value := 1
		value = 2 // OK - not a new declaration
		return value
	}
	
	// Test multi-value assignment with blank identifier - should not shadow blank
	func F22() (int, int) {
		x, _ := 1, 2
		if true {
			y, _ := 3, 4 // OK - blank identifier doesn't shadow
			return x, y
		}
		return x, 0
	}
	
	// Test shadowing with different types - should not trigger
	func F23() int {
		value := 1
		if true {
			value := "string" // OK - different type
			println(value)
		}
		return value
	}
	
	// Test var declaration (GenDecl) shadowing
	func F24() int {
		value := 1
		if true {
			value := 2 // Bad - shadows
			~~~~~
!!! shadow: declaration of "value" shadows declaration at line 416 and is reachable from use at line 421
			println(value)
		}
		return value
	}
	
	// Test shadowing in function literal (triggers FuncLit path in cfgFor)
	func F25() int {
		value := 1
		fn := func() int {
			if true {
				value := 2 // Bad - shadows outer value
				~~~~~
!!! shadow: declaration of "value" shadows non-local declaration at line 426
				return value
			}
			return value
		}
		return fn()
	}
	
	// Test mixed := where one var is already defined (covers obj == nil case)
	func F26() (int, int) {
		value := 1
		err := error(nil)
		if true {
			value, err := 2, error(nil) // value is new, err is reassigned
			~~~~~
!!! shadow: declaration of "value" shadows declaration at line 439 and is reachable from use at line 447
			       ~~~
!!! shadow: declaration of "err" shadows declaration at line 440 and is reachable from use at line 446
			_ = err
			println(value)
		}
		_ = err
		return value, 0
	}
	
	// Test shadowed variable with use
	func F27() int {
		value := 1
		if true {
			value := 2 // Bad - shadows
			~~~~~
!!! shadow: declaration of "value" shadows declaration at line 452 and is reachable from use at line 457
			println(value)
		}
		return value
	}
	
	// Test shadowing within same function literal (triggers FuncLit case in cfgFor)
	var F28 = func() int {
		value := 1
		if true {
			value := 2 // Bad - shadows within same func lit
			~~~~~
!!! shadow: declaration of "value" shadows declaration at line 462 and is reachable from use at line 467
			println(value)
		}
		return value
	}
	
	// Test cycle detection in CFG - loop where shadow is used after loop
	func F29() int {
		value := 1
		for i := 0; i < 10; i++ {
			if i == 5 {
				value := 2 // Bad - shadows and loop creates CFG cycle
				~~~~~
!!! shadow: declaration of "value" shadows declaration at line 472 and is reachable from use at line 479
				println(value)
			}
		}
		return value
	}
	
	// Test shadow with use in successor block (triggers reachable in successor)
	func F30() int {
		value := 1
		if true {
			value := 2 // Bad - shadows
			~~~~~
!!! shadow: declaration of "value" shadows declaration at line 484 and is reachable from use at line 491
			if true {
				println(value) // use is in a successor block
			}
		}
		return value
	}
	
	// Test shadow with multiple successor blocks
	func F31(cond bool) int {
		value := 1
		if cond {
			value := 2 // Bad
			~~~~~
!!! shadow: declaration of "value" shadows declaration at line 496 and is reachable from use at line 505
			if cond {
				println(value)
			} else {
				println(value)
			}
		}
		return value
	}
	
	// Test := with mixed new/existing variables (triggers obj == nil path)
	func F32() (int, error) {
		value := 1
		err := error(nil)
		// In this :=, 'value' is reassigned (not new) so Defs[value] is nil
		// 'other' is new, so only 'other' would be checked for shadowing
		value, other := 2, 3
		_ = err
		_ = other
		return value, nil
	}
	
