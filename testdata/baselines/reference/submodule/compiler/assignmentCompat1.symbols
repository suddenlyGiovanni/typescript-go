//// [tests/cases/compiler/assignmentCompat1.ts] ////

=== assignmentCompat1.ts ===
var x = { one: 1 };
>x : Symbol(x, Decl(assignmentCompat1.ts, 0, 3))
>one : Symbol(one, Decl(assignmentCompat1.ts, 0, 9))

declare var y: { [index: string]: any };
>y : Symbol(y, Decl(assignmentCompat1.ts, 1, 11))
>index : Symbol(index, Decl(assignmentCompat1.ts, 1, 18))

declare var z: { [index: number]: any };
>z : Symbol(z, Decl(assignmentCompat1.ts, 2, 11))
>index : Symbol(index, Decl(assignmentCompat1.ts, 2, 18))

x = y;  // Error
>x : Symbol(x, Decl(assignmentCompat1.ts, 0, 3))
>y : Symbol(y, Decl(assignmentCompat1.ts, 1, 11))

y = x;  // Ok because index signature type is any
>y : Symbol(y, Decl(assignmentCompat1.ts, 1, 11))
>x : Symbol(x, Decl(assignmentCompat1.ts, 0, 3))

x = z;  // Error
>x : Symbol(x, Decl(assignmentCompat1.ts, 0, 3))
>z : Symbol(z, Decl(assignmentCompat1.ts, 2, 11))

z = x;  // Ok because index signature type is any
>z : Symbol(z, Decl(assignmentCompat1.ts, 2, 11))
>x : Symbol(x, Decl(assignmentCompat1.ts, 0, 3))

y = "foo"; // Error
>y : Symbol(y, Decl(assignmentCompat1.ts, 1, 11))

z = "foo"; // OK, string has numeric indexer
>z : Symbol(z, Decl(assignmentCompat1.ts, 2, 11))

z = false; // Error
>z : Symbol(z, Decl(assignmentCompat1.ts, 2, 11))


