--- old.genericArgumentCallSigAssignmentCompat.types
+++ new.genericArgumentCallSigAssignmentCompat.types
@@= skipped -10, +10 lines =@@
  
     export interface Static {
         all<T>(list: T[], iterator?: Iterator<T, boolean>, context?: any): boolean;
->all : <T>(list: T[], iterator?: Iterator<T, boolean>, context?: any) => boolean
+>all : <T>(list: T[], iterator?: Iterator<T, boolean> | undefined, context?: any) => boolean
 >list : T[]
 >iterator : Iterator<T, boolean> | undefined
 >context : any
@@= skipped -19, +19 lines =@@
 // Ideally, we would not have a generic signature here, because it should be instantiated with {} during inferential typing
 _.all([true, 1, null, 'yes'], _.identity);
 >_.all([true, 1, null, 'yes'], _.identity) : boolean
->_.all : <T>(list: T[], iterator?: Underscore.Iterator<T, boolean>, context?: any) => boolean
+>_.all : <T>(list: T[], iterator?: Underscore.Iterator<T, boolean> | undefined, context?: any) => boolean
 >_ : Underscore.Static
->all : <T>(list: T[], iterator?: Underscore.Iterator<T, boolean>, context?: any) => boolean
+>all : <T>(list: T[], iterator?: Underscore.Iterator<T, boolean> | undefined, context?: any) => boolean
 >[true, 1, null, 'yes'] : (string | number | true | null)[]
 >true : true
 >1 : 1
@@= skipped -14, +14 lines =@@
 // Ok, because fixing makes us infer boolean for T
 _.all([true], _.identity);
 >_.all([true], _.identity) : boolean
->_.all : <T>(list: T[], iterator?: Underscore.Iterator<T, boolean>, context?: any) => boolean
+>_.all : <T>(list: T[], iterator?: Underscore.Iterator<T, boolean> | undefined, context?: any) => boolean
 >_ : Underscore.Static
->all : <T>(list: T[], iterator?: Underscore.Iterator<T, boolean>, context?: any) => boolean
+>all : <T>(list: T[], iterator?: Underscore.Iterator<T, boolean> | undefined, context?: any) => boolean
 >[true] : true[]
 >true : true
 >_.identity : <T>(value: T) => T