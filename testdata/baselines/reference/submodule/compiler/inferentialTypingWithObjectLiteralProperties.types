//// [tests/cases/compiler/inferentialTypingWithObjectLiteralProperties.ts] ////

=== inferentialTypingWithObjectLiteralProperties.ts ===
function f<T>(x: T, y: T): T {
>f : <T>(x: T, y: T) => T
>x : T
>y : T

return x;
>x : T
}
f({ x: [null] }, { x: [1] }).x[0] = "" // ok
>f({ x: [null] }, { x: [1] }).x[0] = "" : ""
>f({ x: [null] }, { x: [1] }).x[0] : number | null
>f({ x: [null] }, { x: [1] }).x : null[] | number[]
>f({ x: [null] }, { x: [1] }) : { x: null[]; } | { x: number[]; }
>f : <T>(x: T, y: T) => T
>{ x: [null] } : { x: null[]; }
>x : null[]
>[null] : null[]
>{ x: [1] } : { x: number[]; }
>x : number[]
>[1] : number[]
>1 : 1
>x : null[] | number[]
>0 : 0
>"" : ""

f({ x: [1] }, { x: [null] }).x[0] = "" // was error TS2011: Cannot convert 'string' to 'number'.
>f({ x: [1] }, { x: [null] }).x[0] = "" : ""
>f({ x: [1] }, { x: [null] }).x[0] : number | null
>f({ x: [1] }, { x: [null] }).x : null[] | number[]
>f({ x: [1] }, { x: [null] }) : { x: number[]; } | { x: null[]; }
>f : <T>(x: T, y: T) => T
>{ x: [1] } : { x: number[]; }
>x : number[]
>[1] : number[]
>1 : 1
>{ x: [null] } : { x: null[]; }
>x : null[]
>[null] : null[]
>x : null[] | number[]
>0 : 0
>"" : ""

