//// [tests/cases/compiler/iterableWithNeverAsUnionMember.ts] ////

=== iterableWithNeverAsUnionMember.ts ===
declare const o1: { a: "foo" } & { a: "bar" };
>o1 : never
>a : "foo"
>a : "bar"

const [el1] = o1; // error
>el1 : never
>o1 : never

// https://github.com/microsoft/TypeScript/issues/62462
declare var x: number[] | ({ t: "a" } & { t: "b" });
>x : number[]
>t : "a"
>t : "b"

let [el2] = x; // ok
>el2 : number
>x : number[]

for (const elem of x) { // ok
>elem : number
>x : number[]

  elem.toFixed();
>elem.toFixed() : string
>elem.toFixed : (fractionDigits?: number | undefined) => string
>elem : number
>toFixed : (fractionDigits?: number | undefined) => string
}

type Shape =
>Shape : Shape

  | { kind: "circle"; radius: number }
>kind : "circle"
>radius : number

  | { kind: "rectangle"; width: number; height: number };
>kind : "rectangle"
>width : number
>height : number

type Circle = Shape & { kind: "circle" };
>Circle : { kind: "circle"; radius: number; } & { kind: "circle"; }
>kind : "circle"

function doStuffWithCircle(arg: Circle | [Circle, (newValue: Circle) => void]) {
>doStuffWithCircle : (arg: [{ kind: "circle"; radius: number; } & { kind: "circle"; }, (newValue: { kind: "circle"; radius: number; } & { kind: "circle"; }) => void] | ({ kind: "circle"; radius: number; } & { kind: "circle"; })) => void
>arg : [{ kind: "circle"; radius: number; } & { kind: "circle"; }, (newValue: { kind: "circle"; radius: number; } & { kind: "circle"; }) => void] | ({ kind: "circle"; radius: number; } & { kind: "circle"; })
>newValue : { kind: "circle"; radius: number; } & { kind: "circle"; }

  if (Array.isArray(arg)) {
>Array.isArray(arg) : boolean
>Array.isArray : (arg: any) => arg is any[]
>Array : ArrayConstructor
>isArray : (arg: any) => arg is any[]
>arg : [{ kind: "circle"; radius: number; } & { kind: "circle"; }, (newValue: { kind: "circle"; radius: number; } & { kind: "circle"; }) => void] | ({ kind: "circle"; radius: number; } & { kind: "circle"; })

    let [value, setValue] = arg; // ok
>value : { kind: "circle"; radius: number; } & { kind: "circle"; }
>setValue : (newValue: { kind: "circle"; radius: number; } & { kind: "circle"; }) => void
>arg : [{ kind: "circle"; radius: number; } & { kind: "circle"; }, (newValue: { kind: "circle"; radius: number; } & { kind: "circle"; }) => void]
  }
}

function f1<T extends { a: "foo" } & { a: "bar" }>(x: T) {
>f1 : <T extends never>(x: T) => void
>a : "foo"
>a : "bar"
>x : T

  let [y] = x; // error
>y : never
>x : T
}

declare const o2: ({ a: "foo" } & { a: "bar" }) | ({ b: "qwe" } & { b: "rty" });
>o2 : never
>a : "foo"
>a : "bar"
>b : "qwe"
>b : "rty"

const [el3] = o2; // error
>el3 : never
>o2 : never

