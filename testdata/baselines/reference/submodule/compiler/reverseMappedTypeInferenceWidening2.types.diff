--- old.reverseMappedTypeInferenceWidening2.types
+++ new.reverseMappedTypeInferenceWidening2.types
@@= skipped -9, +9 lines =@@
 }): T;

 const res1 = test1({
->res1 : { foo: { prop: number; prop2: string; }; bar: { prop: boolean; prop2: null; }; }
->test1({  foo: {    prop: 1,    prop2: "",  },  bar: {    prop: true,    prop2: null,  },}) : { foo: { prop: number; prop2: string; }; bar: { prop: boolean; prop2: null; }; }
+>res1 : Record<string, { prop: unknown; }>
+>test1({  foo: {    prop: 1,    prop2: "",  },  bar: {    prop: true,    prop2: null,  },}) : Record<string, { prop: unknown; }>
 >test1 : <T extends Record<string, { prop: unknown; }>>(arg: { [K in keyof T]: T[K]; }) => T
->{  foo: {    prop: 1,    prop2: "",  },  bar: {    prop: true,    prop2: null,  },} : { foo: { prop: number; prop2: string; }; bar: { prop: true; prop2: null; }; }
+>{  foo: {    prop: 1,    prop2: "",  },  bar: {    prop: true,    prop2: null,  },} : { foo: { prop: number; prop2: string; }; bar: { prop: boolean; prop2: null; }; }

   foo: {
 >foo : { prop: number; prop2: string; }
@@= skipped -19, +19 lines =@@

   },
   bar: {
->bar : { prop: true; prop2: null; }
->{    prop: true,    prop2: null,  } : { prop: true; prop2: null; }
+>bar : { prop: boolean; prop2: null; }
+>{    prop: true,    prop2: null,  } : { prop: boolean; prop2: null; }

     prop: true,
->prop : true
+>prop : boolean
 >true : true

     prop2: null,