//// [tests/cases/conformance/types/specifyingTypes/typeLiterals/arrayTypeOfTypeOf.ts] ////

=== arrayTypeOfTypeOf.ts ===
// array type cannot use typeof.

var x = 1;
>x : number
>1 : 1

var xs: typeof x[];  // Not an error.  This is equivalent to Array<typeof x>
>xs : number[]
>x : number

var xs2: typeof Array;
>xs2 : ArrayConstructor
>Array : ArrayConstructor

var xs3: typeof Array<number>;
>xs3 : { (arrayLength: number): number[]; (...items: number[]): number[]; new (arrayLength: number): number[]; new (...items: number[]): number[]; isArray(arg: any): arg is any[]; readonly prototype: any[]; from<T>(arrayLike: ArrayLike<T>): T[]; from<T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[]; from<T>(iterable: ArrayLike<T> | Iterable<T>): T[]; from<T, U>(iterable: ArrayLike<T> | Iterable<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[]; of<T>(...items: T[]): T[]; readonly [Symbol.species]: ArrayConstructor; }
>Array : ArrayConstructor

var xs4: typeof Array<typeof x>;
>xs4 : { (arrayLength: number): number[]; (...items: number[]): number[]; new (arrayLength: number): number[]; new (...items: number[]): number[]; isArray(arg: any): arg is any[]; readonly prototype: any[]; from<T>(arrayLike: ArrayLike<T>): T[]; from<T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[]; from<T>(iterable: ArrayLike<T> | Iterable<T>): T[]; from<T, U>(iterable: ArrayLike<T> | Iterable<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[]; of<T>(...items: T[]): T[]; readonly [Symbol.species]: ArrayConstructor; }
>Array : ArrayConstructor
>x : number

