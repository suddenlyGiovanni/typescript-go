//// [tests/cases/conformance/types/typeParameters/typeParameterLists/typeParameterConstModifiersReturnsAndYields.ts] ////

=== typeParameterConstModifiersReturnsAndYields.ts ===
enum E { Val, Val2 }
>E : E
>Val : E.Val
>Val2 : E.Val2

declare function test1<const T>(create: () => T): T;
>test1 : <const T>(create: () => T) => T
>create : () => T

const result1 = test1(() => ['a']);
>result1 : readonly ["a"]
>test1(() => ['a']) : readonly ["a"]
>test1 : <const T>(create: () => T) => T
>() => ['a'] : () => readonly ["a"]
>['a'] : ["a"]
>'a' : "a"

const result2 = test1(() => `a${Math.random()}`);
>result2 : `a${number}`
>test1(() => `a${Math.random()}`) : `a${number}`
>test1 : <const T>(create: () => T) => T
>() => `a${Math.random()}` : () => `a${number}`
>`a${Math.random()}` : `a${number}`
>Math.random() : number
>Math.random : () => number
>Math : Math
>random : () => number

const result3 = test1(() => 'a');
>result3 : string
>test1(() => 'a') : string
>test1 : <const T>(create: () => T) => T
>() => 'a' : () => string
>'a' : "a"

const result4 = test1(() => true);
>result4 : boolean
>test1(() => true) : boolean
>test1 : <const T>(create: () => T) => T
>() => true : () => boolean
>true : true

const result5 = test1(() => 101n);
>result5 : bigint
>test1(() => 101n) : bigint
>test1 : <const T>(create: () => T) => T
>() => 101n : () => bigint
>101n : 101n

const result6 = test1(() => false);
>result6 : boolean
>test1(() => false) : boolean
>test1 : <const T>(create: () => T) => T
>() => false : () => boolean
>false : false

const result7 = test1(() => 11111);
>result7 : number
>test1(() => 11111) : number
>test1 : <const T>(create: () => T) => T
>() => 11111 : () => number
>11111 : 11111

const result8 = test1(() => E.Val);
>result8 : E
>test1(() => E.Val) : E
>test1 : <const T>(create: () => T) => T
>() => E.Val : () => E
>E.Val : E.Val
>E : typeof E
>Val : E.Val

const result9 = test1(() => { return ['a']; });
>result9 : readonly ["a"]
>test1(() => { return ['a']; }) : readonly ["a"]
>test1 : <const T>(create: () => T) => T
>() => { return ['a']; } : () => readonly ["a"]
>['a'] : ["a"]
>'a' : "a"

const result10 = test1(() => { return `a${Math.random()}`; });
>result10 : `a${number}`
>test1(() => { return `a${Math.random()}`; }) : `a${number}`
>test1 : <const T>(create: () => T) => T
>() => { return `a${Math.random()}`; } : () => `a${number}`
>`a${Math.random()}` : `a${number}`
>Math.random() : number
>Math.random : () => number
>Math : Math
>random : () => number

const result11 = test1(() => { return 'a'; });
>result11 : string
>test1(() => { return 'a'; }) : string
>test1 : <const T>(create: () => T) => T
>() => { return 'a'; } : () => string
>'a' : "a"

const result12 = test1(() => { return true; });
>result12 : boolean
>test1(() => { return true; }) : boolean
>test1 : <const T>(create: () => T) => T
>() => { return true; } : () => boolean
>true : true

const result13 = test1(() => { return 101n; });
>result13 : bigint
>test1(() => { return 101n; }) : bigint
>test1 : <const T>(create: () => T) => T
>() => { return 101n; } : () => bigint
>101n : 101n

const result14 = test1(() => { return false; });
>result14 : boolean
>test1(() => { return false; }) : boolean
>test1 : <const T>(create: () => T) => T
>() => { return false; } : () => boolean
>false : false

const result15 = test1(() => { return 11111; });
>result15 : number
>test1(() => { return 11111; }) : number
>test1 : <const T>(create: () => T) => T
>() => { return 11111; } : () => number
>11111 : 11111

const result16 = test1(() => { return E.Val; });
>result16 : E
>test1(() => { return E.Val; }) : E
>test1 : <const T>(create: () => T) => T
>() => { return E.Val; } : () => E
>E.Val : E.Val
>E : typeof E
>Val : E.Val

const result17 = test1(async () => 'foo');
>result17 : Promise<string>
>test1(async () => 'foo') : Promise<string>
>test1 : <const T>(create: () => T) => T
>async () => 'foo' : () => Promise<string>
>'foo' : "foo"

const result18 = test1(async () => { return 'foo'; });
>result18 : Promise<string>
>test1(async () => { return 'foo'; }) : Promise<string>
>test1 : <const T>(create: () => T) => T
>async () => { return 'foo'; } : () => Promise<string>
>'foo' : "foo"

declare function test2<const T>(create: () => Promise<T>): T;
>test2 : <const T>(create: () => Promise<T>) => T
>create : () => Promise<T>

const result19 = test2(async () => 'foo');
>result19 : string
>test2(async () => 'foo') : string
>test2 : <const T>(create: () => Promise<T>) => T
>async () => 'foo' : () => Promise<string>
>'foo' : "foo"

const result20 = test2(async () => { return 'foo'; });
>result20 : string
>test2(async () => { return 'foo'; }) : string
>test2 : <const T>(create: () => Promise<T>) => T
>async () => { return 'foo'; } : () => Promise<string>
>'foo' : "foo"

declare function test3<const T, const R>(arg: () => Generator<T, R>): [T, R]
>test3 : <const T, const R>(arg: () => Generator<T, R, any>) => [T, R]
>arg : () => Generator<T, R, any>

const result21 = test3(function*() {
>result21 : [number, string]
>test3(function*() {    yield 10;    return '1';}) : [number, string]
>test3 : <const T, const R>(arg: () => Generator<T, R, any>) => [T, R]
>function*() {    yield 10;    return '1';} : () => Generator<number, string, any>

    yield 10;
>yield 10 : any
>10 : 10

    return '1';
>'1' : "1"

});

declare function test4<const T, const R>(arg: () => AsyncGenerator<T, R>): [T, R]
>test4 : <const T, const R>(arg: () => AsyncGenerator<T, R, any>) => [T, R]
>arg : () => AsyncGenerator<T, R, any>

const result22 = test4(async function*() {
>result22 : [number, string]
>test4(async function*() {    yield 10;    return '1';}) : [number, string]
>test4 : <const T, const R>(arg: () => AsyncGenerator<T, R, any>) => [T, R]
>async function*() {    yield 10;    return '1';} : () => AsyncGenerator<number, string, any>

    yield 10;
>yield 10 : any
>10 : 10

    return '1';
>'1' : "1"

});

// https://github.com/microsoft/TypeScript/issues/53813
const UploadThingServerHelper = <const ValidRoutes,>(route: {
>UploadThingServerHelper : <const ValidRoutes>(route: { readonly [Route in keyof ValidRoutes]: { middleware: () => ValidRoutes[Route]; onUpload: (response: { metadata: ValidRoutes[Route]; }) => void; }; }) => void
><const ValidRoutes,>(route: {  readonly [Route in keyof ValidRoutes]: {    middleware: () => ValidRoutes[Route];    onUpload: (response: { metadata: ValidRoutes[Route] }) => void;  };}) => {} : <const ValidRoutes>(route: { readonly [Route in keyof ValidRoutes]: { middleware: () => ValidRoutes[Route]; onUpload: (response: { metadata: ValidRoutes[Route]; }) => void; }; }) => void
>route : { readonly [Route in keyof ValidRoutes]: { middleware: () => ValidRoutes[Route]; onUpload: (response: { metadata: ValidRoutes[Route]; }) => void; }; }

  readonly [Route in keyof ValidRoutes]: {
    middleware: () => ValidRoutes[Route];
>middleware : () => ValidRoutes[Route]

    onUpload: (response: { metadata: ValidRoutes[Route] }) => void;
>onUpload : (response: { metadata: ValidRoutes[Route]; }) => void
>response : { metadata: ValidRoutes[Route]; }
>metadata : ValidRoutes[Route]

  };
}) => {};

const FileRouter = UploadThingServerHelper({
>FileRouter : void
>UploadThingServerHelper({  example: {    middleware: () => "someValue",    onUpload: (response) => {      const v: "someValue" = response.metadata;    },  },}) : void
>UploadThingServerHelper : <const ValidRoutes>(route: { readonly [Route in keyof ValidRoutes]: { middleware: () => ValidRoutes[Route]; onUpload: (response: { metadata: ValidRoutes[Route]; }) => void; }; }) => void
>{  example: {    middleware: () => "someValue",    onUpload: (response) => {      const v: "someValue" = response.metadata;    },  },} : { example: { middleware: () => string; onUpload: (response: { metadata: string; }) => void; }; }

  example: {
>example : { middleware: () => string; onUpload: (response: { metadata: string; }) => void; }
>{    middleware: () => "someValue",    onUpload: (response) => {      const v: "someValue" = response.metadata;    },  } : { middleware: () => string; onUpload: (response: { metadata: string; }) => void; }

    middleware: () => "someValue",
>middleware : () => string
>() => "someValue" : () => string
>"someValue" : "someValue"

    onUpload: (response) => {
>onUpload : (response: { metadata: string; }) => void
>(response) => {      const v: "someValue" = response.metadata;    } : (response: { metadata: string; }) => void
>response : { metadata: string; }

      const v: "someValue" = response.metadata;
>v : "someValue"
>response.metadata : string
>response : { metadata: string; }
>metadata : string

    },
  },
});

function outer1<const T>(cb: () => T) {
>outer1 : <const T>(cb: () => T) => <const U>(cb2: () => U) => (T | U)[]
>cb : () => T

  function inner1<const U>(cb2: () => U) {
>inner1 : <const U>(cb2: () => U) => (T | U)[]
>cb2 : () => U

    return [cb(), cb2()];
>[cb(), cb2()] : (T | U)[]
>cb() : T
>cb : () => T
>cb2() : U
>cb2 : () => U
  }
  return inner1;
>inner1 : <const U>(cb2: () => U) => (T | U)[]
}
const nestedResult1 = outer1(() => 1)(() => "foo");
>nestedResult1 : (string | number)[]
>outer1(() => 1)(() => "foo") : (string | number)[]
>outer1(() => 1) : <const U>(cb2: () => U) => (number | U)[]
>outer1 : <const T>(cb: () => T) => <const U>(cb2: () => U) => (T | U)[]
>() => 1 : () => number
>1 : 1
>() => "foo" : () => string
>"foo" : "foo"

function outer2<T>(cb: () => T) {
>outer2 : <T>(cb: () => T) => <const U>(cb2: () => U) => (T | U)[]
>cb : () => T

  function inner2<const U>(cb2: () => U) {
>inner2 : <const U>(cb2: () => U) => (T | U)[]
>cb2 : () => U

    return [cb(), cb2()];
>[cb(), cb2()] : (T | U)[]
>cb() : T
>cb : () => T
>cb2() : U
>cb2 : () => U
  }
  return inner2;
>inner2 : <const U>(cb2: () => U) => (T | U)[]
}
const nestedResult2 = outer2(() => 1)(() => "foo");
>nestedResult2 : (string | number)[]
>outer2(() => 1)(() => "foo") : (string | number)[]
>outer2(() => 1) : <const U>(cb2: () => U) => (number | U)[]
>outer2 : <T>(cb: () => T) => <const U>(cb2: () => U) => (T | U)[]
>() => 1 : () => number
>1 : 1
>() => "foo" : () => string
>"foo" : "foo"

function outer3<const T>(cb: () => T) {
>outer3 : <const T>(cb: () => T) => <U>(cb2: () => U) => (T | U)[]
>cb : () => T

  function inner3<U>(cb2: () => U) {
>inner3 : <U>(cb2: () => U) => (T | U)[]
>cb2 : () => U

    return [cb(), cb2()];
>[cb(), cb2()] : (T | U)[]
>cb() : T
>cb : () => T
>cb2() : U
>cb2 : () => U
  }
  return inner3;
>inner3 : <U>(cb2: () => U) => (T | U)[]
}
const nestedResult3 = outer3(() => 1)(() => "foo");
>nestedResult3 : (string | number)[]
>outer3(() => 1)(() => "foo") : (string | number)[]
>outer3(() => 1) : <U>(cb2: () => U) => (number | U)[]
>outer3 : <const T>(cb: () => T) => <U>(cb2: () => U) => (T | U)[]
>() => 1 : () => number
>1 : 1
>() => "foo" : () => string
>"foo" : "foo"

declare function overloaded1<const T>(cb: () => T): T;
>overloaded1 : { <const T>(cb: () => T): T; <const T, const U>(cb: () => T, cb2: () => U): [T, U]; }
>cb : () => T

declare function overloaded1<const T, const U>(cb: () => T, cb2: () => U): [T, U];
>overloaded1 : { <const T>(cb: () => T): T; <const T, const U>(cb: () => T, cb2: () => U): [T, U]; }
>cb : () => T
>cb2 : () => U

const overloadA = overloaded1(() => 42);
>overloadA : number
>overloaded1(() => 42) : number
>overloaded1 : { <const T>(cb: () => T): T; <const T, const U>(cb: () => T, cb2: () => U): [T, U]; }
>() => 42 : () => number
>42 : 42

const overloadB = overloaded1(() => "hi", () => true);
>overloadB : [string, boolean]
>overloaded1(() => "hi", () => true) : [string, boolean]
>overloaded1 : { <const T>(cb: () => T): T; <const T, const U>(cb: () => T, cb2: () => U): [T, U]; }
>() => "hi" : () => string
>"hi" : "hi"
>() => true : () => boolean
>true : true

declare function overloaded2<T>(cb: () => T): T;
>overloaded2 : { <T>(cb: () => T): T; <T, const U>(cb: () => T, cb2: () => U): [T, U]; }
>cb : () => T

declare function overloaded2<T, const U>(cb: () => T, cb2: () => U): [T, U];
>overloaded2 : { <T>(cb: () => T): T; <T, const U>(cb: () => T, cb2: () => U): [T, U]; }
>cb : () => T
>cb2 : () => U

const overloadC = overloaded2(() => 42);
>overloadC : number
>overloaded2(() => 42) : number
>overloaded2 : { <T>(cb: () => T): T; <T, const U>(cb: () => T, cb2: () => U): [T, U]; }
>() => 42 : () => number
>42 : 42

const overloadD = overloaded2(() => "hi", () => true);
>overloadD : [string, boolean]
>overloaded2(() => "hi", () => true) : [string, boolean]
>overloaded2 : { <T>(cb: () => T): T; <T, const U>(cb: () => T, cb2: () => U): [T, U]; }
>() => "hi" : () => string
>"hi" : "hi"
>() => true : () => boolean
>true : true

declare function overloaded3<const T>(cb: () => T): T;
>overloaded3 : { <const T>(cb: () => T): T; <const T, U>(cb: () => T, cb2: () => U): [T, U]; }
>cb : () => T

declare function overloaded3<const T, U>(cb: () => T, cb2: () => U): [T, U];
>overloaded3 : { <const T>(cb: () => T): T; <const T, U>(cb: () => T, cb2: () => U): [T, U]; }
>cb : () => T
>cb2 : () => U

const overloadE = overloaded3(() => 42);
>overloadE : number
>overloaded3(() => 42) : number
>overloaded3 : { <const T>(cb: () => T): T; <const T, U>(cb: () => T, cb2: () => U): [T, U]; }
>() => 42 : () => number
>42 : 42

const overloadF = overloaded3(() => "hi", () => true);
>overloadF : [string, boolean]
>overloaded3(() => "hi", () => true) : [string, boolean]
>overloaded3 : { <const T>(cb: () => T): T; <const T, U>(cb: () => T, cb2: () => U): [T, U]; }
>() => "hi" : () => string
>"hi" : "hi"
>() => true : () => boolean
>true : true

declare function overloaded4<const T>(cb: () => T): T;
>overloaded4 : { <const T>(cb: () => T): T; <T, U>(cb: () => T, cb2: () => U): [T, U]; }
>cb : () => T

declare function overloaded4<T, U>(cb: () => T, cb2: () => U): [T, U];
>overloaded4 : { <const T>(cb: () => T): T; <T, U>(cb: () => T, cb2: () => U): [T, U]; }
>cb : () => T
>cb2 : () => U

const overloadG = overloaded4(() => 42);
>overloadG : number
>overloaded4(() => 42) : number
>overloaded4 : { <const T>(cb: () => T): T; <T, U>(cb: () => T, cb2: () => U): [T, U]; }
>() => 42 : () => number
>42 : 42

const overloadH = overloaded4(() => "hi", () => true);
>overloadH : [string, boolean]
>overloaded4(() => "hi", () => true) : [string, boolean]
>overloaded4 : { <const T>(cb: () => T): T; <T, U>(cb: () => T, cb2: () => U): [T, U]; }
>() => "hi" : () => string
>"hi" : "hi"
>() => true : () => boolean
>true : true

declare function overloaded5<T>(cb: () => T): T;
>overloaded5 : { <T>(cb: () => T): T; <const T, U>(cb: () => T, cb2: () => U): [T, U]; }
>cb : () => T

declare function overloaded5<const T, U>(cb: () => T, cb2: () => U): [T, U];
>overloaded5 : { <T>(cb: () => T): T; <const T, U>(cb: () => T, cb2: () => U): [T, U]; }
>cb : () => T
>cb2 : () => U

const overloadI = overloaded5(() => 42);
>overloadI : number
>overloaded5(() => 42) : number
>overloaded5 : { <T>(cb: () => T): T; <const T, U>(cb: () => T, cb2: () => U): [T, U]; }
>() => 42 : () => number
>42 : 42

const overloadJ = overloaded5(() => "hi", () => true);
>overloadJ : [string, boolean]
>overloaded5(() => "hi", () => true) : [string, boolean]
>overloaded5 : { <T>(cb: () => T): T; <const T, U>(cb: () => T, cb2: () => U): [T, U]; }
>() => "hi" : () => string
>"hi" : "hi"
>() => true : () => boolean
>true : true

